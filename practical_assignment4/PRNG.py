import math

# the code uses the notation from the theory in the book/report

# total is the number of random bits/numbers to generate
total=100

def power(a,b,c):
    x=1
    y=a
 
    while b>0:
        if b%2!=0:
            x=(x*y)%c
        y=(y*y)%c
        b=int(b/2)

    return x%c

# Blum Blum Shub Generator (BBSG)
p=383
q=503
n=192649  # n = p x q
s=101355  # s is a random seed

x0_BBSG=power(s,2,n) # x0 = (s^2) mod n

def get_samples_BBSG(x0,n_samples):
    lis=[]
    for i in range(0,n_samples):
        x0=power(x0,2,n)   # xi = ((x_(i-1))^2)mod n
        lis.append(x0%2) # Bi = xi mod 2
        
    return lis

print('{} Random bits generated by the Blum Blum Shub Generator are: '.format(total))
numbers_BBSG=get_samples_BBSG(x0_BBSG,total)
for num in numbers_BBSG:
    print(num,end=' ')
    
# Exclusive OR Generator (XORG)
bits_127='0001011011011001000101111001001010011011101101000100000010101111111010100100001010110110000000000100110000101110011111111100111'

def get_samples_XORG(bits,n_samples):
    lis=[]
    for i in range(len(bits)):
        lis.append(int(bits[i]))  # convert bit stting (bits_127) into integers 0 and 1
        
    for i in range(127,127+n_samples):
        lis.append(lis[-1]^lis[i-126]) # xi = x_(i-1) ^ x_(i-127) (the code used 126 because of zero indexing, indexing starts from 1 in theory) 
        
    return lis[127:]
    
print('\n\n{} Random bits generated by the Exclusive OR Generator are: '.format(total))
numbers_XORG=get_samples_XORG(bits_127,total)
for num in numbers_XORG:
    print(num,end=' ')

# Tests
#Frequency test
def freq(lis):
    s=0 # frequency of 0's and 1's respectively
    for num in lis:
        if num==0: # calculate S be adding -1 if 0 is found
            s-=1
        else: s+=1 # calculate S be adding 1 if 1 is found
        
    s_obs=abs(s)/math.sqrt(len(lis))  # get S_obs = |S|/srqt(N) 
    p=math.erfc(s_obs/math.sqrt(2))  # get P-value as erfc(S_obs/sqrt(2))
    
    print('P-value = {}'.format(p))
    if p >= 0.01: # check if P-value is greater than or equal to 0.01
        print('Since P-value is greater than or equal to 0.01 the sequence is random.')
    else:
        print('Since P-value is less than 0.01 the sequence is not random.')

# Runs test
def bit_runs(lis):
    n=len(lis) # get N length of sequence
    pi=sum(lis)/n # get π = fraction of 1's in the sequence
    v=0
    for i in range(len(lis)-1):
        if lis[i]!=lis[i+1]: v+=1 # calculate V_N(obs) by adding 1 to it if two consecutive bits are unequal
    
    p=math.erfc(abs(v-2*n*pi*(1-pi))/(2*math.sqrt(2*n)*pi*(1-pi))) # get P-value = erfc(|V_N(obs)-2Nπ(1-π)|/(2*sqrt(2N)*π(1-π)))
    
    print('P-value = {}'.format(p))
    if p >= 0.01: # check if P-value is greater than or equal to 0.01
        print('Since P-value is greater than or equal to 0.01 the sequence is random.')
    else:
        print('Since P-value is less than 0.01 the sequence is not random.')
    
print('\n\nThe tests use the {} random bits printed on the console for both the PRNGs.'.format(total))
    
# Running Frequency test of BBSG
print('\n\nRunning Frequency test of BBSG')
freq(numbers_BBSG)

# Running Runs test of BBSG
print('\n\nRunning Runs test of BBSG')
bit_runs(numbers_BBSG)

# Running Frequency test of BBSG
print('\n\nRunning Frequency test of XORG')
freq(numbers_XORG)

# Running Runs test of BBSG
print('\n\nRunning Runs test of XORG')
bit_runs(numbers_XORG)